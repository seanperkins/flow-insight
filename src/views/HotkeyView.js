import React, {Component} from "react";
import {Button, Dropdown, Grid, Icon, Input} from "semantic-ui-react";
import {RendererControllerFactory} from "../controllers/RendererControllerFactory";
import {DimensionController} from "../controllers/DimensionController";
import {HotkeyClient} from "../clients/HotkeyClient";

/**
 *  This view class is used to show a floating hotkey configuration window
 */
export default class HotkeyView extends Component {
  constructor(props) {
    super(props);

    this.state = {
      feedbackMsg: "",
      hotkeyStr: "key",
      currentMetaKey: "Control",
      currentHotKey: "",
      isShiftPressed: false,
      shortcuts: []
    }

    this.currentFocusIndex = 0;
    this.metaKeyOptions = [
      {key: "Control", value: "Control", text: "Ctrl"},
      {key: "Alt", value: "Alt", text: "Alt"},
      {key: "Command", value: "Command", text: "Cmd"}
    ];
  }

  componentDidMount() {
    HotkeyClient.init(this);

    HotkeyClient.getCurrentShortcuts(this, (arg) => {
      if (arg.data) {
        this.setState({
          shortcuts: arg.data.shortcuts
        });
      } else {
        console.error(arg.error);
      }
    });
  }


  onClickClose = () => {
    console.log("close window!");
    let hotkeyConfigController =
      RendererControllerFactory.getViewController(
        RendererControllerFactory.Views.HOTKEY_CONFIG,
        this
      );

    hotkeyConfigController.closeHotkeyWindow();
  };

  onClickSave = () => {
    console.log("click save!");

    let feedback = "";

    for (let shortcut of this.state.shortcuts) {
      if (shortcut.key.length === 0) {
        feedback = "Key cannot be empty";
      }
    }

    if (!feedback) {
      HotkeyClient.updateShortcuts(this.state.shortcuts, this,(arg) => {
        if (arg.error) {
          feedback = arg.error;
        } else {
          feedback = "Changes saved.";
        }
        this.setState({
          feedbackMsg: feedback
        });
      });
    }

  }

  onClickCancel = () => {
    console.log("click cancel!");
    this.onClickClose();
  }

  /**
   * When a new key is pressed for the hotkey
   * @param e
   */
  handleKeyPressForHotkey = (e) => {
    console.log(e.key);
    console.log(e.charCode);
    console.log(e.shiftKey); // boolean
    console.log(e.ctrlKey); // boolean
    console.log(e.altKey); // boolean
    console.log(e.metaKey);

    this.setState((prevState) => {
      prevState.shortcuts[this.currentFocusIndex].hasShift = e.shiftKey;
      return {
        shortcuts: prevState.shortcuts
      };
    });

  };

  /**
   * Whenever the input field is changed
   * @param e - the event that was generated by user gui event
   * @param value
   */
  handleChangeForHotkey = (e, { value }) => {
    console.log("change!");
    if (value.length > 0) {
      value = value.substring(value.length - 1);
    }

    this.setState((prevState) => {
      prevState.shortcuts[this.currentFocusIndex].key = value;
      return {
        shortcuts: prevState.shortcuts
      };
    });
  };

  /**
   * Whenever the metakey dropdown field was changed
   * @param e - the event that was generated by user gui event
   * @param value
   */
  handleChangeForMetaKey = (e, { value }) => {
    console.log(value);

    this.setState((prevState) => {
      prevState.shortcuts[this.currentFocusIndex].modifier = value;
      return {
        shortcuts: prevState.shortcuts
      };
    });
  };

  focusIndex(index) {
    this.currentFocusIndex = index;
  }

  setInputFocusClass(elId) {
    let el = document.getElementById(elId);
    if (el != null) {
      el.classList.add("focused");
    }
  }

  removeInputFocusClass(elId) {
    let el = document.getElementById(elId);
    if (el != null) {
      el.classList.remove("focused");
    }
  }

  getHotkeyRow(shortcut, index) {

    console.log("accelerator = |"+this.state.shortcuts[index].modifier + "|");

    return (
    <Grid.Row key={index}>
      <Grid.Column width={6} className="chunkTitle">
        <div>{shortcut.friendlyName}</div>
      </Grid.Column>
      <Grid.Column width={6} id={"metakeyInput"+index}>
        <Dropdown
          id={"metakeyId" + index}
          className="metakeyInput"
          options={this.metaKeyOptions}
          selection
          fluid
          value={this.state.shortcuts[index].modifier}
          onFocus={() => {this.focusIndex(index); this.setInputFocusClass("metakeyInput"+index)}}
          onBlur={() => {this.removeInputFocusClass("metakeyInput"+index)}}
          onChange={this.handleChangeForMetaKey}
        />
      </Grid.Column>
      <Grid.Column width={4}>
        <Input className="hotkeyInput"
               placeholder={this.state.hotkeyStr}
               value={this.state.shortcuts[index].key}
               onFocus={() => {this.focusIndex(index);}}
               onKeyPress={this.handleKeyPressForHotkey}
               onChange={this.handleChangeForHotkey}/>
      </Grid.Column>
    </Grid.Row>);

  }

  getHotkeyTable() {
    return (<Grid
        id="hotkey-row-grid"
        className="hotkeyTable"
        inverted
        columns={16}
      >
      {
        this.state.shortcuts.map((shortcut, i) => {
          return this.getHotkeyRow(shortcut, i);
        })
      }
      </Grid>
    );
  }

  /// renders the view into our root element of our window
  render() {

    let height = DimensionController.getHeightFor(
      DimensionController.Components.HOTKEY_CONFIG
    );

    return (
      <div id="component" className="hotkeyLayout">
        <div className="closeIcon">
          <Icon
            name="close"
            size="large"
            onClick={this.onClickClose}
          />
        </div>
        <div className="configBox"
           style={{
             height: height,
           }}>
          <div className="title">Configure Hotkeys</div>

          {this.getHotkeyTable()}

          <div className="feedback">{this.state.feedbackMsg}</div>
          <div className="buttons">
            <Button
              onClick={this.onClickCancel}
              size="medium"
              color="grey"
            >
              <Button.Content>Cancel</Button.Content>
            </Button>
            <Button
              onClick={this.onClickSave}
              size="medium"
              color="violet"
            >
              <Button.Content>Save</Button.Content>
            </Button>
          </div>
        </div>
      </div>
    );
  }
}
